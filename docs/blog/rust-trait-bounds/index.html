<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Rust: Trait Bounds | Vineel Kovvuri</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="shortcut icon" href="/images/favicon.ico" />
    <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" rel="stylesheet">

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/blog/">Blog</a></li>
      
      <li><a href="/presentations/">Presentations</a></li>
      
      <li><a href="/bookmarks/">Bookmarks</a></li>
      
      <li><a href="/tools/">Tools</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Rust: Trait Bounds</span></h1>


<h3 class="date">
    2025/06/21
    
        |
        <a href="/tags/rust">Rust</a>
        
    
</h3>

</div>


    
        <aside class="toc">
            <h2>Table of Contents</h2>
            <nav id="TableOfContents">
  <ul>
    <li><a href="#rust-trait-bounds">Rust: Trait Bounds</a>
      <ul>
        <li><a href="#generic-traits">Generic Traits</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    


<main>
<h1 id="rust-trait-bounds">Rust: Trait Bounds</h1>
<p>Traits in Rust is one of core features of the language. But it deserve some
explanation. Though they may sometimes be called similar to interfaces they are
far more flexible. Lets try to understand what they are and how they can be
used.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">trait</span><span style="color:#bbb"> </span>Book<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">get_type</span>(&amp;self)<span style="color:#bbb"> </span>-&gt; <span style="color:#038">String</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>This defines trait not a type. traits != types. Traits can be thought of a
collection of features that are applicable to the implementing type. Traits
themselves are not very useful unless they are implemented by types.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">impl</span><span style="color:#bbb"> </span>Book<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">for</span><span style="color:#bbb"> </span>EBook<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">get_type</span>(&amp;self)<span style="color:#bbb"> </span>-&gt; <span style="color:#038">String</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#34;Hard Bounded&#34;</span>.to_string();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">impl</span><span style="color:#bbb"> </span>Book<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">for</span><span style="color:#bbb"> </span>HardBook<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">get_type</span>(&amp;self)<span style="color:#bbb"> </span>-&gt; <span style="color:#038">String</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span><span style="color:#080;font-weight:bold">return</span><span style="color:#bbb"> </span><span style="color:#d20;background-color:#fff0f0">&#34;Pdf&#34;</span>.to_string();<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>By applying <code>Book</code> trait to <code>Ebook</code> and <code>HardBook</code> we are establishing a
contract with the implementing types(like interfaces). Now the beauty is we can
write functions which can work on the trait generically.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">protect</span>&lt;T&gt;(book: <span style="color:#b06;font-weight:bold">T</span>)<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">where</span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>T: <span style="color:#b06;font-weight:bold">Book</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>book.get_type()<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><h2 id="generic-traits">Generic Traits</h2>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">trait</span><span style="color:#bbb"> </span>Book&lt;F&gt;<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">set_type</span>(&amp;self,<span style="color:#bbb"> </span>book_type: <span style="color:#b06;font-weight:bold">F</span>);<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>Jokes apart, Rust lifetimes are notoriously difficult to master. I have to
confess — I don&rsquo;t fully understand them either. But today’s article will shed
some light on the topic.</p>
<p>The concept of lifetimes in programming languages is not new — every variable in
C, for instance, has a lifetime associated with it. In simple terms, a
<strong>lifetime</strong> indicates how long a variable remains alive and can be safely used.
However, in most other languages, this concept is hidden, and we generally do
not have the tools to explicitly express it. While this may often seem
unnecessary, it&rsquo;s precisely the kind of topic that, when mishandled, can lead to
hard-to-debug crashes or bugs — such as dangling references.</p>
<p>Fortunately or unfortunately, Rust brings this concept to the forefront and
provides special syntax to express lifetimes. Before we go any further, we need
to understand exactly <strong>where</strong> lifetimes are used. Lifetimes come into play
when dealing with <strong>references</strong>. Unlike most other languages, Rust guarantees
the safety of reference variables while they are being used. This is only
possible if the Rust compiler (specifically, the <em>borrow checker</em>) can prove
that the variable a reference points to will remain valid for the entire
duration of that reference&rsquo;s use. This is made possible by explicitly annotating
references with an additional <strong>lifetime parameter</strong>.</p>
<p>We specify the lifetime of a reference using the <code>'a</code> syntax. Writing lifetime
annotations on every reference would hurt the language’s usability, so the
compiler tries to <strong>infer</strong> them in common cases. This process is known as
<strong>lifetime elision</strong>. Fortunately, the rules for when we need to specify
lifetimes and when the compiler can infer them are relatively straightforward.
We’ll discuss them in more detail later.</p>
<blockquote>
<p><strong>Tip 1:</strong> Rust Analyzer in VS Code helps display inlay hints for
compiler-inferred lifetimes. You can enable this by going to <strong>Settings &gt;
Extensions &gt; Rust Analyzer &gt; Inlay Hints &gt; Lifetime Elision Hints</strong>. This can
be quite handy at times.</p>
</blockquote>
<blockquote>
<p><strong>Tip 2:</strong> Always rely on <code>cargo check</code> to get detailed information about any
lifetime parameter violations.</p>
</blockquote>
<p>Now lets look at some cases to understand the lifetimes better.</p>
<p><strong>Case 1: References confined to a single scope:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>x<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">10</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>y<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span>&amp;x;<span style="color:#bbb">
</span></span></span></code></pre></div><p>It is safe to use <code>y</code> as long as <code>x</code> is alive. Rust can infer the lifetime of
<code>x</code> and the validity of <code>y</code> because they are declared in the same scope. So, we
don&rsquo;t need to explicitly specify the lifetime of the reference here. However,
this becomes particularly necessary when passing and returning references in
functions.</p>
<p><strong>Case 2: Function returning References to local variables:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>()<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>a<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">10</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;a<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>error[E0106]: missing lifetime specifier
</span></span><span style="display:flex;"><span> --&gt; src\main.rs:2:14
</span></span><span style="display:flex;"><span>  |
</span></span><span style="display:flex;"><span>2 | fn func() -&gt; &amp;u32 {
</span></span><span style="display:flex;"><span>  |              ^ expected named lifetime parameter
</span></span><span style="display:flex;"><span>  |
</span></span><span style="display:flex;"><span>  = help: this function&#39;s return type contains a borrowed value, but there is no value for it to be borrowed from
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>error[E0515]: cannot return reference to local variable `a`
</span></span><span style="display:flex;"><span> --&gt; src\main.rs:4:5
</span></span><span style="display:flex;"><span>  |
</span></span><span style="display:flex;"><span>4 |     &amp;a
</span></span><span style="display:flex;"><span>  |     ^^ returns a reference to data owned by the current function
</span></span></code></pre></div><p>You cannot simply do that! As we know from working in C, the lifetime of the
variable <code>a</code> is limited to the end of the function. So, trying to return a
reference to that variable is a footgun. The only way to return a reference to a
local variable is if we know that the variable has a <code>'static</code> lifetime (we’ll
talk about this later).</p>
<p><strong>Case 3: Function returning References to input reference variables:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>(arr: <span style="color:#080">&amp;</span>[<span style="color:#888;font-weight:bold">u32</span>])<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;arr[<span style="color:#00d;font-weight:bold">0</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>With Rust analyzer inlay hits</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>&lt;<span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span>&gt;(arr: <span style="color:#080">&amp;</span><span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span>[<span style="color:#888;font-weight:bold">u32</span>])<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span><span style="color:#888;font-weight:bold">u32</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;arr[<span style="color:#00d;font-weight:bold">2</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>This works because we are trying to return a reference to an element of a slice
that shares the same lifetime (as indicated by the lifetime parameter).</p>
<p><strong>By default, the compiler will automatically assign a lifetime to the input
parameter, and the same lifetime is assigned to all output reference
parameters.</strong> However, if there are multiple input reference parameters, the
compiler will assign different lifetime parameters to each. In such cases, the
output reference parameter must explicitly specify which input lifetime it is
tied to, as shown below.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>(arr1: <span style="color:#080">&amp;</span>[<span style="color:#888;font-weight:bold">u32</span>],<span style="color:#bbb"> </span>arr2: <span style="color:#080">&amp;</span>[<span style="color:#888;font-weight:bold">u32</span>])<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;arr1[<span style="color:#00d;font-weight:bold">0</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>With Rust analyzer inlay hits</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>&lt;<span style="color:#a61717;background-color:#e3d2d2">`</span><span style="color:#00d;font-weight:bold">0</span>,<span style="color:#a61717;background-color:#e3d2d2">`</span><span style="color:#00d;font-weight:bold">1</span>&gt;(arr1: <span style="color:#080">&amp;</span><span style="color:#a61717;background-color:#e3d2d2">`</span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span>[<span style="color:#888;font-weight:bold">u32</span>],<span style="color:#bbb"> </span>arr2: <span style="color:#080">&amp;</span><span style="color:#a61717;background-color:#e3d2d2">`</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#bbb"> </span>[<span style="color:#888;font-weight:bold">u32</span>])<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;arr1[<span style="color:#00d;font-weight:bold">0</span>]<span style="color:#bbb">                                        </span>^----<span style="color:#bbb"> </span>Compiler<span style="color:#bbb"> </span>cannot<span style="color:#bbb"> </span>infer<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">                                                         </span>the<span style="color:#bbb"> </span>lifetime<span style="color:#bbb"> </span><span style="color:#080;font-weight:bold">as</span><span style="color:#bbb"> </span>there<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">                                                          </span>are<span style="color:#bbb"> </span>more<span style="color:#bbb"> </span>than<span style="color:#bbb"> </span>one<span style="color:#bbb">
</span></span></span></code></pre></div><p><strong>Solution:</strong> Pick a lifetime from one of the input parameters to let the
compiler know that the returned reference comes from <code>arr1</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>&lt;<span style="color:#369">&#39;a</span>&gt;(arr1: <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span>[<span style="color:#888;font-weight:bold">u32</span>],<span style="color:#bbb"> </span>arr2: <span style="color:#080">&amp;</span>[<span style="color:#888;font-weight:bold">u32</span>])<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span> <span style="color:#888;font-weight:bold">u32</span> {<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;arr1[<span style="color:#00d;font-weight:bold">0</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>Now this raises the question: what if the function has to return a reference
from <code>arr2</code> based on some logic? Again, we have to prove to the compiler that,
in either case, the lifetime of the reference being returned is long enough. We
can specify this as shown below.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">func</span>&lt;<span style="color:#369">&#39;a</span>,<span style="color:#bbb"> </span><span style="color:#369">&#39;b</span>&gt;(arr1: <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span> [<span style="color:#888;font-weight:bold">u32</span>],<span style="color:#bbb"> </span>arr2: <span style="color:#080">&amp;</span><span style="color:#369">&#39;b</span> [<span style="color:#888;font-weight:bold">u32</span>])<span style="color:#bbb"> </span>-&gt; <span style="color:#080">&amp;</span><span style="color:#369">&#39;b</span> <span style="color:#888;font-weight:bold">u32</span>
</span></span><span style="display:flex;"><span><span style="color:#b06;font-weight:bold">where</span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#369">&#39;a</span>: <span style="color:#369">&#39;b</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>&amp;arr2[<span style="color:#00d;font-weight:bold">0</span>]<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>The constraint <code>'a: 'b</code> means that <code>'a</code> lives at least as long as <code>'b</code>, and we
specify that the returned reference has at least the <code>'b</code> lifetime. By doing
this, we guarantee to the compiler that no matter what we return (a reference to
an element of <code>arr2</code> or <code>arr1</code>), the returned reference will live long enough.
<strong>Note:</strong> We specify the shortest lifetime annotation (<code>'b</code>) in the return type.</p>
<p><strong>Case 4: Structures containing references:</strong></p>
<p>Now lets look at the case where structure fields can reference some other data.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">BookView</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span>price: <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span>pages: <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>Again, when we create an object of this struct, we need to make sure that the
references inside the object point to data that can live as long as the struct
itself. The only way the compiler can guarantee this is by assigning a lifetime
parameter. <strong>Note:</strong> Each reference can have its own lifetime parameter. For
simplicity, let&rsquo;s assume both references point to data with the same lifetime.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">struct</span> <span style="color:#b06;font-weight:bold">BookView</span>&lt;<span style="color:#369">&#39;a</span>&gt;<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span>price: <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span> <span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">  </span>pages: <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span> <span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>What we are telling the compiler is that whenever this struct is used, it must
ensure the data it points to is valid.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">main</span>()<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>price<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">100</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>pages<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span><span style="color:#00d;font-weight:bold">1000</span>;<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">let</span><span style="color:#bbb"> </span>bv<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>price: <span style="color:#080">&amp;</span><span style="color:#b06;font-weight:bold">price</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>pages: <span style="color:#080">&amp;</span><span style="color:#b06;font-weight:bold">pages</span>,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>};<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p><code>bv</code> is valid in the as the data its fields point to are in the same scope.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">create_book_view</span>(price: <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb"> </span>pages: <span style="color:#080">&amp;</span><span style="color:#888;font-weight:bold">u32</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>price,<span style="color:#bbb"> </span>pages<span style="color:#bbb"> </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>This does not compile because, as we discussed before, each input reference
parameter gets its own lifetime parameter, and the compiler assigns a new
lifetime parameter to the output as well.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">create_book_view</span>&lt;<span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span>,<span style="color:#bbb"> </span><span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">1</span>,<span style="color:#bbb"> </span><span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">2</span>&gt;(price: <span style="color:#080">&amp;</span><span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span><span style="color:#bbb"> </span><span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb"> </span>pages: <span style="color:#080">&amp;</span><span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#bbb"> </span><span style="color:#888;font-weight:bold">u32</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span>&lt;<span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">2</span>&gt;<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>price,<span style="color:#bbb"> </span>pages<span style="color:#bbb"> </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>Now we are trying to create a <code>BookView</code> using parameters that have different
lifetimes, so the compiler cannot infer the struct&rsquo;s lifetime parameter. By now,
the fix should be obvious.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">create_book_view</span>&lt;<span style="color:#369">&#39;a</span>&gt;(price: <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span> <span style="color:#888;font-weight:bold">u32</span>,<span style="color:#bbb"> </span>pages: <span style="color:#080">&amp;</span><span style="color:#369">&#39;a</span> <span style="color:#888;font-weight:bold">u32</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span>&lt;<span style="color:#369">&#39;a</span>&gt;<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>price,<span style="color:#bbb"> </span>pages<span style="color:#bbb"> </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>We are telling the compiler that <code>BookView</code>’s lifetime parameter is the same as
the lifetime parameter of the inputs. In other words, the data referenced by the
struct’s fields can live as long as the input parameters.</p>
<blockquote>
<p>One thing to note here is that the output parameter is not a reference itself,
unlike in our previous examples. However, the output parameter <strong>does</strong>
require lifetime information to manage its fields. So, we are <strong>not</strong>
returning <code>&amp;BookView</code>.</p>
</blockquote>
<blockquote>
<p>The lifetime parameter of the output is <strong>only</strong> inferred when there is
exactly one input to the function. When the function has more than one
parameter, even if the lifetimes of those parameters are explicitly specified,
the lifetime of the output parameter must be explicitly specified as well.</p>
</blockquote>
<p>Let&rsquo;s look at some more examples of this</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">create_book_view3</span>(bv: <span style="color:#b06;font-weight:bold">BookView</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>price: <span style="color:#b06;font-weight:bold">bv</span>.price,<span style="color:#bbb"> </span>pages: <span style="color:#b06;font-weight:bold">bv</span>.pages<span style="color:#bbb"> </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>Since the function has only one parameter, we can elide the lifetime annotations
both on the input and the output. As mentioned before, the compiler will infer
them to be the same lifetime.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">create_book_view3</span>&lt;<span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span>&gt;(bv: <span style="color:#b06;font-weight:bold">BookView</span>&lt;<span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span>&gt;)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span>&lt;<span style="color:#369">&#39;</span><span style="color:#00d;font-weight:bold">0</span>&gt;<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb"> </span>price: <span style="color:#b06;font-weight:bold">bv</span>.price,<span style="color:#bbb"> </span>pages: <span style="color:#b06;font-weight:bold">bv</span>.pages<span style="color:#bbb"> </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p><strong>Case 5: Structures containing references and its implication on methods:</strong></p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span><span style="color:#080;font-weight:bold">impl</span>&lt;<span style="color:#369">&#39;a</span>&gt;<span style="color:#bbb"> </span>BookView&lt;<span style="color:#369">&#39;a</span>&gt;<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#888">// For methods, the output lifetime parameter is same as that of self. But
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// one thing to note is, &amp;self itself will have a new lifetime parameter it
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// is not the same as `&#39;a`. Think of below
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// fn clone_book_view&lt;&#39;0&gt;(&amp;&#39;0 self) -&gt; BookView&lt;&#39;0&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">clone_book_view</span>(&amp;self)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>price: <span style="color:#b06;font-weight:bold">self</span>.price,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>pages: <span style="color:#b06;font-weight:bold">self</span>.pages,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span><span style="color:#888">// For methods, the output lifetime parameter is same as that of self. But
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// one thing to note is, &amp;self itself will have a new lifetime parameter it
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// is not the same as `&#39;a`.
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">//
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// Below do not work,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// fn copy_book_view_update&lt;&#39;0, &#39;1&gt;(&amp;&#39;0 self, pages: &amp;&#39;1 u32) -&gt; BookView&lt;&#39;0&gt; {
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// fn copy_book_view_update(&amp;self, pages: &amp;u32) -&gt; BookView {
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">//     BookView {
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">//         price: self.price,
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">//         pages,                 &lt;--- This is using &#39;1 lifetime
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">//     }
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// }
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#888">// we have to explicitly specify that self and pages have same lifetime
</span></span></span><span style="display:flex;"><span><span style="color:#888"></span><span style="color:#bbb">    </span><span style="color:#080;font-weight:bold">fn</span> <span style="color:#06b;font-weight:bold">copy_book_view_update</span>&lt;<span style="color:#369">&#39;x</span>&gt;(&amp;<span style="color:#369">&#39;x</span><span style="color:#bbb"> </span>self,<span style="color:#bbb"> </span>pages: <span style="color:#080">&amp;</span><span style="color:#369">&#39;x</span> <span style="color:#888;font-weight:bold">u32</span>)<span style="color:#bbb"> </span>-&gt; <span style="color:#b06;font-weight:bold">BookView</span><span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>BookView<span style="color:#bbb"> </span>{<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>price: <span style="color:#b06;font-weight:bold">self</span>.price,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">            </span>pages,<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">        </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb">    </span>}<span style="color:#bbb">
</span></span></span><span style="display:flex;"><span><span style="color:#bbb"></span>}<span style="color:#bbb">
</span></span></span></code></pre></div><p>In essence, below is the gist of how lifetime <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision">elision
rules</a>
work:</p>
<ul>
<li>Every input reference parameter gets a unique lifetime annotation.</li>
<li>If there is only one input reference parameter, then all output reference
parameters get the same lifetime as that input.</li>
<li>If the first parameter is <code>self</code>, then all output reference parameters get the
lifetime of <code>self</code>.</li>
</ul>

</main>

  <footer>
  
<script defer src="/js/center-img.js"></script>







  
  <hr/>
  © Vineel Kumar Reddy Kovvuri 2017 &ndash; 2025 ❤️ <a href="https://xmin.yihui.org/">Hugo Xmin</a>
  
  </footer>
  </body>
</html>

